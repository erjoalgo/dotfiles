;; -*- mode: lisp; -*-
(in-package :stumpwm)

(load (merge-pathnames ".sbclrc" (user-homedir-pathname)))

(defparameter *retain-messages-p* nil
  "when non-nil, retain old messages in addition to new one.
when the value is :log, the latest message goes to the bottom as in a log file")

(defmacro with-retained-messages (order &body body)
  `(progn
     (setf (screen-current-msg (current-screen)) nil)
     (let ((*retain-messages-p* ,order))
       ,@body)))

;; rewrite of echo-string-list to support retaining messages
(defun echo-string-list (screen strings &rest highlights)
  "Draw each string in l in the screen's message window. HIGHLIGHT is
  the nth entry to highlight."
  (when strings
    (when *retain-messages-p*
      (setf strings
            (if (eq :log *retain-messages-p*)
                (append (screen-current-msg screen) strings)
                (append strings (screen-current-msg screen)))))
    (unless *executing-stumpwm-command*
      (multiple-value-bind (width height)
          (rendered-size strings (screen-message-cc screen))
        (setup-message-window screen width height)
        (render-strings (screen-message-cc screen)
                        *message-window-padding*
                        *message-window-y-padding*
                        strings
                        highlights))
      (setf (screen-current-msg screen)
            strings
            (screen-current-msg-highlights screen)
            highlights)
      ;; Set a timer to hide the message after a number of seconds
      (if *suppress-echo-timeout*
          ;; any left over timers need to be canceled.
          (when (timer-p *message-window-timer*)
            (cancel-timer *message-window-timer*)
            (setf *message-window-timer* nil))
          (reset-message-window-timer)))
    (push-last-message screen strings highlights)
    (xlib:display-finish-output *display*)
    (dformat 5 "Outputting a message:~%~{        ~a~%~}" strings)
    (apply 'run-hook-with-args *message-hook* strings)))

(defmacro with-elapsed-time (elapsed-time-var form &body body)
  (let ((start-time-sym (gensym "start-time")))
    `(let ((,start-time-sym (get-internal-real-time)))
       ,form
       (let ((,elapsed-time-var (- (get-internal-real-time) ,start-time-sym)))
         ,@body))))

(defun load-safe (pathname)
  "load file, trapping and recording errors"
  ;; (message "loading file: ~A..." pathname)
  (handler-case
      (progn
        (with-elapsed-time elapsed-time (load pathname)
          (message "loaded ~A in ~Dms" (pathname-name pathname) elapsed-time)))
    (error (err)
      (message "error loading: ~A~%: '~A'" pathname err)
      (cons pathname err))))

(defparameter STUMPWM-TOP
  ;; TODO find current file, e.g. __file__
  ;; (UIOP/LISP-BUILD:CURRENT-LISP-FILE-PATHNAME)
  (merge-pathnames  ".stumpwmrc.d/lisp/" (user-homedir-pathname)))

(defparameter browser-classes
  '("Iceweasel" "Firefox"  "Navigator"  "Chromium" "chromium-browser"
    "Tor Browser" "Google-chrome" "Firefox-esr"))

(defparameter browser-name
  (or
   (pathname-name
    (string-trim '(#\newline)
                 (run-shell-command "which chromium chromium-browser chrome google-chrome" t)))
   "chromium"))

(defparameter load-list
  '(
    "util.lisp"
    "xinitrc.lisp"
    "sensitive/sensitive.el"
    "decorations.lisp"
    "defcommands.lisp"
    "tsv-db.lisp"
    "mozrepl.lisp"
    "url-launcher.lisp"

    "run-raise-programs.lisp"
    "per-window-bindings.lisp"
    "top-map-bindings.lisp"

    "commands-map.lisp"
    "swank-loader.lisp"
    "correct-screen.lisp"
    "brightness.lisp"
    "startup-apps.lisp")

  "defines components to load and their order")

(defvar load-extra-directories
  '("commands"))

(defparameter *init-errs* nil )

(let ((_ (message ""))
      (*retain-messages-p* t)
      errs)

  (loop
    for filename in load-list
    do
       (push (load-safe (merge-pathnames
                         filename
                         STUMPWM-TOP))
             errs))

  (dolist (directory-name load-extra-directories)
    (dolist (pathname (directory
                       (make-pathname :name :WILD
                                      :directory (append (pathname-directory STUMPWM-TOP) (list directory-name))
                                      :type "lisp")))
      (when (pathname-name pathname)
        ;; is file
        (push (load-safe pathname) errs))))
  (progn
    (setf *init-errs* (remove-if #'null errs))
    (message "finished loading .stumpwmrc. ~D errors"
             (length *init-errs*))))

;;manual
;;https://stumpwm.github.io/git/stumpwm-git_16.html
