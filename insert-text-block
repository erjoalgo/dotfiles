#!/usr/bin/python
from __future__ import print_function
import sys, argparse, re, os

parser = argparse.ArgumentParser()
parser.add_argument("line", help = "universally unique line")
parser.add_argument("filename", help = "input/output file")
parser.add_argument("-b", "--begining_append",  action="store_true",
                    help = "preppend instead of append")
parser.add_argument("-n", "--no_strip_newline",  action="store_true",
                    help = "don't strip trailing newline from stdin")

args=vars(parser.parse_args())
globals().update(args)

stdin=sys.stdin.read()
if not no_strip_newline and stdin[-1]=="\n":
    stdin=stdin[:-1]
block="\n".join((line, stdin, line))
if not os.path.exists(filename):
    with open( filename, "w") as fh:
        pass
assert(os.path.exists(filename))
orig_text=open(filename).read()
regexp="(?sm)^(.*?)((?:\n)?{0}.*{0}(?:\n)?)(.*)$".format(re.escape(line))
match=re.match(regexp, orig_text)
middle=filter(bool, [match.group(1), match.group(3)]) if match else [orig_text]

if begining_append:
    middle.insert(0, block)
else:
    middle.append(block)

new_text="\n".join(middle)
with open( filename, "w") as fh:
    fh.write(new_text)

# Local Variables:
# mode: python
# compile-command: "./text-block '# 07b37c2c-a63f-11e7-94e3-cff9e57fa83f' test -b  <<< \"$(echo -e 'LINEA\\nLINEB')\""
# End:
