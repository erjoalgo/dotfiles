#!/bin/bash
function find-iregex {
    find ${PWD} -iregex ".*$*.*"
}

function find-name {
    DIR=${1} && shift
    find "${DIR}" -name ${*}
}

function abspath {
     echo $(readlink -f "${1}")
}

function lnabs {
    #http://stackoverflow.com/questions/4187210/convert-relative-symbolic-links-to-absolute-symbolic-links
    relative=$1
    shift
    ln -sf "$(readlink -f "${relative}")" "$*"
}

function lnabs_t {
    target=$1
    relative=$2
    shift
    shift
    ln -s -t ${target} "$(readlink -f "${relative}")"
}

function plusx {
    #echo -e $(find $1 -iregex ".*$2.*")
    dest=${HOME}/bin/$(basename $1)
    abs=$(abspath "$1")
    [ -e ${dest} ] || lnabs ${abs} ${dest}
    chmod +x $1
    #re_source
}

function xargsn {
    xargs -d'\n' -L 1 $*
}
#http://superuser.com/questions/150117/how-to-get-parent-pid-of-a-given-process-in-gnu-linux-from-command-line
ppid () { ps -p ${1:-$$} -o ppid=; }
# http://www.cyberciti.biz/faq/linux-random-password-generator/

function genpasswd {
    local l=$1;
    [ "$l" == "" ] && l=16;
    tr -dc A-Za-z0-9_ < /dev/urandom | head -c ${l} | xargs;
}

function passgen	{
    NAME=${1} && shift
    SPECIAL_FLAG=${SPECIAL_FLAG:--n}
    NOPROMPT_FLAG=${NOPROMPT_FLAG:-}
    LENGTH=""
    LENGTH=${LENGTH:-14}
    pass generate ${SPECIAL_FLAG} ${NOPROMPT_FLAG} ${*} -c ${NAME} ${LENGTH}
    xclip -o -selection clipboard | xclip -i -selection primary
    xclip -o -selection primary
}

function passgen-allow-special	{
    SPECIAL_FLAG=" " passgen ${*}
}


function passgen-pin	{
    NAME=${1} && shift
    LENGTH=""
    LENGTH=${LENGTH:-4}
    PIN=$(tr -dc 0-9 < /dev/urandom | head -c ${LENGTH})
    echo ${PIN} | pass insert --echo ${NAME}
    echo -n ${PIN} | xclip -i -selection clipboard
    xclip -o -selection primary
}

function pass-show-xs	{
  PASS_PATH=${1} && shift
  pass show ${PASS_PATH} | xs
}

for PASS_CMD in passgen{,-allow-special,-pin} pass-show-xs; do
    complete -o filenames -o nospace -F _pass ${PASS_CMD}
done

function test-port	{
    HOST="${1}"
    PORT="${2}"
    # http://stackoverflow.com/questions/9609130/quick-way-to-find-if-a-port-is-open-on-linux
    # echo -e "GET / HTTP/1.0\n" >&6
    # cat <&6
    exec 6<>/dev/tcp/"${HOST}/${PORT}"
}

function beep-on-success {
    until ${*}; do
        sleep 1
    done
    beep
    beep
    beep
    xmessage "success of ${*}"
}

function straceall {
    set -x
    NAME="${1}"
    shift
    strace $* $(pidof "${NAME}" | sed 's/\([0-9]*\)/-p \1/g')
}

function affexact {
    apt-file find "${1}"| grep "/${1}$"
}

function durec	{
    du -ah --max-depth 1 $1 | sort -h
}

function dedup_path	{
    export PATH=$(echo ${PATH} | tr : '\n' | sort | uniq)
}

function append_path	{
    export PATH=$PATH:$1
}

function shred-rec	{
    for FN in $*; do
	read -p "rec shred ${FN}?"
	if test -d "${FN}"; then
	    find "${FN}" -type f -exec shred -zuf {} \;
	    find "${FN}" -type l -exec unlink {} \;
	    find "${FN}" -depth -type d -exec rmdir {} \;
	elif test -L "${FN}"; then
            unlink "${FN}"
	else
	    shred -zufn10 "${FN}"
	fi
    done
}

function is_newline_terminated	{
    LAST_CHAR=$(tail -c1 "${1}")
    test -z "${LAST_CHAR}"
}

function gitignore-append-commit	{
    for IGNORE in ${*}; do
	echo ${IGNORE} >> .gitignore
    done
    git add .gitignore
    git commit -m "gitignore ${1}"
}

function apt_rdepends_r_installed	{
    sudo apt-rdepends -r "${1}" --state-{follow,show}=Installed
}

function git-delete-merged-branches	{
    git branch --merged | g -v '^[*]\|master' | xargs -L 1 git branch -d
}

function git-push-current-branch	{
    BRANCH="$(git rev-parse --abbrev-ref HEAD)"
    REMOTE=${1:-origin} && shift
    git push "${REMOTE}" "${BRANCH}" ${*}
}
__git_complete git-push-current-branch _git_pull

function git-review-pull-request	{
    ORIG_HEAD=$(git rev-parse --abbrev-ref HEAD)

    if grep '[.]\{2\}' > /dev/null <<< "${1}"; then
	SPLIT=$(sed 's/[.]\{2\}/\t/g' <<< "${1}")
	FROM_BRANCH=$(cut -f1 <<< "${SPLIT}")
	TO_BRANCH=$(cut -f2 <<< "${SPLIT}")
	shift
    else
	FROM_BRANCH=${1:-origin/master} && shift
	TO_BRANCH=${1:-${ORIG_HEAD}} && shift
    fi

    if test -z "${CMD}"; then
	# NOLESS only makes sense with a command
	NOLESS=''
    fi

    if test -z "${FROM_BRANCH}" || test -z "${TO_BRANCH}"; then
	echo "usage: git-review-pull-request from-branch to-branch"
	# exit 1
	return
    fi
    HASHES=$(git log --reverse "${FROM_BRANCH}".."${TO_BRANCH}"   \
		 --pretty=format:"%h")
    COUNTER=1
    TOTAL=$(wc -l <<< "${HASHES}" | tr -d ' ')
    FAILED=""

    for HASH in $(tr '\n' ' ' <<< ${HASHES}); do

	if test -n "${CMD}"; then
	    git checkout ${HASH}
	    ${CMD} &> /dev/null &
	    COMPILE_CMD_PID=$!
	fi

	if test -z "${NOLESS}"; then
	    { echo -e "------ON COMMIT ${COUNTER}/${TOTAL} (hash: ${HASH})------\n";\
	      git show ${HASH} -p --stat --color;\
	      }  | less -R;
	fi

	COUNTER=$((COUNTER + 1))

	if test -n "${CMD}"; then
	    wait ${COMPILE_CMD_PID}
	    if test $? -ne 0; then
		FAIL="${HASH}: $(git log -1 --pretty=format:%s ${HASH})"
		FAILED="${FAILED}\n${FAIL}"
		${CMD}
		echo ${FAIL}
		echo -p"failure (${CMD}): "
		notify-send "FAILURE (${CMD}): "
		bash
		read -p"cont (q: quit)? : " CONT
		if test "${CONT}" = q; then
		    git checkout ${ORIG_HEAD}
		    return
		fi
	    fi
	fi
    done
    git checkout ${ORIG_HEAD}
    if test -n "${FAILED}"; then
	echo -e "${FAILED}"
    elif test -n "${CMD}"; then
	echo "BUILD SUCCESS on every commit!"
    fi
}

function pid-listening-at	{
    LINE=$(sudo netstat -tlpn 2>/dev/null | grep "[^0-9]${1}[^0-9]")
    PID=$(grep -o '[0-9]*/' <<< "${LINE}" | cut -f1 -d/)
    echo -e "${LINE}\n" 1>&2
    ps -fp ${PID} -w 30 1>&2
    echo ${PID}
}

function git-browse-remote	{
    REMOTE="${1:-origin}" && shift
    URL=$(git config --get "remote.${REMOTE}.url" |  \
	      sed -e 's|:|/|g' -e 's|^\(ssh///\)\?git@|https://|')
    echo ${URL}
    firefox-new-tab "${URL}"
}
# completion with remotes
__git_complete git-browse-remote _git_pull

function cert-fetch	{
    HOSTPORT=${1} && shift
    PEM=/tmp/last-cert.pem
    openssl s_client -showcerts -connect ${HOSTPORT}  \
	    2>/dev/null  \
	    < /dev/null \
	    > ${PEM}

    openssl x509 -in ${PEM} -text -fingerprint | less
    echo ${PEM}
}

function gpom	{
    REMOTE=${1:-origin} && shift
    BRANCH=${1:-$(git rev-parse --abbrev-ref HEAD 2> /dev/null)} && shift
    (
	GIT_TERMINAL_PROMPT=0 git push ${REMOTE} ${BRANCH} &>/dev/null </dev/null
	LAST=$?
	if test 0 -ne $LAST; then
	    echo
	    echo "gpom failed with $LAST!"
	    set -x
	    GIT_TERMINAL_PROMPT=0 git push ${REMOTE} ${BRANCH}
	    set +x
	fi
    ) &
    disown %-
}
__git_complete gpom _git_pull #complete by remote

function mvbk	{
    mv ${1} ${1}.bak
}

function bkmv	{
    mv ${1} $(dirname ${1})/$(basename ${1} .bak)
}

function grvv	{
    REMOTE=${1:-origin} && shift
    git config --get remote.${REMOTE}.url
}
__git_complete grvv _git_pull

function ssh-copy-id-to-user	{
  local OPTIND
  USAGE=false
  while getopts "u:n:p:i:o:h" OPT; do
    case ${OPT} in
      u)
        SSH_LOGIN_USER=${OPTARG}
        ;;
      n)
        SSH_HOSTNAME=${OPTARG}
        ;;
      i)
        IDENTITY_FILE=${OPTARG}
        ;;
      o)
        # extra ssh opts
        SSH_OPTS=${OPTARG}
        ;;
      h)
        USAGE=true
        ;;
    esac
  done

  SSH_LOGIN_USER=${SSH_LOGIN_USER:-${USER}}
  IDENTITY_FILE=${IDENTITY_FILE:-${HOME}/.ssh/id_rsa.pub}

  shift $((OPTIND - 1))

  if test ${USAGE} = true -o -z "${SSH_HOSTNAME}"; then
    echo "usage: ssh-copy-id-to-user [-u SSH_LOGIN_USER] [-o ssh_extra_opts] \
-n SSH_HOSTNAME [-i IDENTITY_FILE] [CP_DEST_USER...]"
    return 1
  fi

  if test ${#*} -eq 0; then
    CP_DEST_USERS=${SSH_LOGIN_USER}
  else
    CP_DEST_USERS=${*}
  fi

  if ! grep "[.]pub\|[.]pem" <<< "${IDENTITY_FILE}" || ! test -e ${IDENTITY_FILE}; then
    echo "bad identity file: ${IDENTITY_FILE}"
    return 1
  fi

  SSH_CMD="ssh ${SSH_OPTS} ${SSH_LOGIN_USER}@${SSH_HOSTNAME}"
  for REMOTE_USER in $CP_DEST_USERS; do
    echo "adding to user ${REMOTE_USER} the key ${IDENTITY_FILE} via ${SSH_CMD}"
    ${SSH_CMD} "sudo -u ${REMOTE_USER} bash -s" <<EOF
set -ex
cd
mkdir -p .ssh && cd .ssh
touch authorized_keys && chmod 644 authorized_keys
tee -a authorized_keys <<EOFF
$(cat ${IDENTITY_FILE})
EOFF
EOF
  done
}

function git-remote-exists	{
    REMOTE=${1} && shift
    git config remote.${REMOTE}.url > /dev/null
}

function git-promote-remote-to-origin	{
    EXISTING=${1} && shift
    if test -z "${EXISTING}" || ! git-remote-exists ${EXISTING}; then
	echo "error: remote ${EXISTING} doesn't exist"
    else
	if git-remote-exists origin; then
	    # rename origin
	    OLD_ORIGIN_NEW_NAME=${1:-old-origin} && shift

	    if git-remote-exists ${OLD_ORIGIN_NEW_NAME}; then
		echo "error: provide a new name for origin"
		return
	    else
		git remote rename origin ${OLD_ORIGIN_NEW_NAME}
	    fi
	fi
	git remote rename ${EXISTING} origin
    fi
}
__git_complete git-promote-remote-to-origin _git_pull

function ps-tree	{
    CURR=${1}
    while test ${CURR} != 1; do
	ps -fp ${CURR}
	CURR=$(ps -o ppid= -p ${CURR})
    done
}

function gg    {
    git grep ${*} $(git rev-list --all)
}

function git-merge-base-show    {
    git show $(git merge-base ${*})
}

function git-filter-branch-rewrite-path-sed    {
    SED_EXP=${1} && shift
    git filter-branch -f --index-filter '
  git ls-files -s | sed "${SED_EXP}" |
  GIT_INDEX_FILE=$GIT_INDEX_FILE.new git update-index --index-info &&
  mv $GIT_INDEX_FILE.new $GIT_INDEX_FILE
' HEAD
}

function git5-start-single {
    local OPTIND
    USAGE=false
    while getopts "n:d:h" OPT; do
        case ${OPT} in
            n)
                NAME=${OPTARG}
                echo "name is ${NAME}"
                G3PATH=${G3PATH:-experimental/users/${USER}/git/${NAME}}
                ;;
            d)
                G3PATH=${OPTARG}
                NAME=${NAME:-$(basename "${G3PATH}")}
                ;;
            h)
                USAGE=true
                ;;
        esac
    done

    if test true = "${USAGE}" -o -z "${G3PATH}" -o -z "${NAME}"; then
        echo "usage: git5-start-repo [-d GOOGLE3_RELATIVE_PATH] [-n NAME]"
        return
    fi


    TOP=${HOME}/git/${NAME}
    if test -d ${TOP}; then
        echo "warn: ${TOP} already exists..."
    else
        mkdir -p ${TOP}
    fi

    prodcertstatus || prodaccess
    cd ${TOP}
    test -e READONLY || git5 start ${NAME} ${G3PATH} --import-empty
    cd ${TOP}/google3/${G3PATH}
}

function PATH-append {
  export PATH=${PATH}:${1}
}

function post-command-notify {
  RET=$?
  history -a
  # green or red
  test ${RET} = 0 && MSG="^2Process completed" || MSG="^1Process erred"

  # xprop -id ${WINDOWID}
  # emacsclient -e '(stumpwm-visible-window-pids)'

  if [[ -n "${WINDOWID}" &&  \
    ! "$(emacsclient -e '(stumpwm-visible-window-ids)')" = *"${WINDOWID}"* ]] ; then
    # window is not visible
    stumpwm-msg ${MSG}
  fi
}

if command -v emacsclient >/dev/null \
  && command -v stumpwm >/dev/null; then
  PROMPT_COMMAND=post-command-notify
fi

function jar-to-classes {
    for JAR in ${*}; do
        for CLASS in $(jar -tf ${JAR}); do
            echo ${JAR} "-\>" ${CLASS}
        done
    done
}
