#!/bin/bash
function find-iregex {
    find ${PWD} -iregex ".*$*.*" 
}

function find-name {
    DIR=${1} && shift
    find "${DIR}" -name ${*}
}

function abspath {
     echo $(readlink -f "${1}")
}

function lnabs {
    #http://stackoverflow.com/questions/4187210/convert-relative-symbolic-links-to-absolute-symbolic-links
    relative=$1
    shift
    ln -sf "$(readlink -f "${relative}")" "$*"
}

function lnabs_t {
    target=$1
    relative=$2
    shift
    shift
    ln -s -t ${target} "$(readlink -f "${relative}")"
}

function plusx {
    #echo -e $(find $1 -iregex ".*$2.*")
    dest=${HOME}/bin/$(basename $1)
    abs=$(abspath "$1")
    [ -e ${dest} ] || lnabs ${abs} ${dest}
    chmod +x $1
    #re_source
}

function xargsn {
    xargs -d'\n' -L 1 $*
}
#http://superuser.com/questions/150117/how-to-get-parent-pid-of-a-given-process-in-gnu-linux-from-command-line
ppid () { ps -p ${1:-$$} -o ppid=; }
# http://www.cyberciti.biz/faq/linux-random-password-generator/

function genpasswd {
    local l=$1;
    [ "$l" == "" ] && l=16;
    tr -dc A-Za-z0-9_ < /dev/urandom | head -c ${l} | xargs;
}

function passgen	{
    NAME=${1} && shift
    pass generate -n ${NAME} 10
}

function test_port	{
    HOST="${1}"
    PORT="${2}"
    # http://stackoverflow.com/questions/9609130/quick-way-to-find-if-a-port-is-open-on-linux
    # echo -e "GET / HTTP/1.0\n" >&6
    # cat <&6
    exec 6<>/dev/tcp/"${HOST}/${PORT}"
}

function straceall {
    set -x
    NAME="${1}"
    shift
    strace $* $(pidof "${NAME}" | sed 's/\([0-9]*\)/-p \1/g')
}

function affexact {
    apt-file find "${1}"| grep "/${1}$"
}

function durec	{
    du -ah --max-depth 1 $1 | sort -h
}

function dedup_path	{
    export PATH=$(echo ${PATH} | tr : '\n' | sort | uniq)
}

function append_path	{
    export PATH=$PATH:$1
}

function shred-rec	{
    for FN in $*; do
	read -p "rec shred ${FN}?"
	if test -d "${FN}"; then
	    find "${FN}" -type f -exec shred -zuf {} \;
	    find "${FN}" -depth -type d -exec rmdir {} \;
	else
	    shred -zufn10 "${FN}"
	fi
    done
}

function is_newline_terminated	{
    LAST_CHAR=$(tail -c1 "${1}")
    test -z "${LAST_CHAR}"
}

function gitignore-append-commit	{
    for IGNORE in ${*}; do
	echo ${IGNORE} >> .gitignore
    done
    git add .gitignore
    git commit -m "gitignore ${1}"
}

function apt_rdepends_r_installed	{
    sudo apt-rdepends -r "${1}" --state-{follow,show}=Installed
}

function git-delete-merged-branches	{
    git branch --merged | g -v '^[*]\|master' | xargs -L 1 git branch -d
}

function git-push-current-branch	{
    BRANCH="$(git rev-parse --abbrev-ref HEAD)"
    # REMOTE=${1:-origin}
    REMOTE="${1}"
    shift
    git push "${REMOTE}" "${BRANCH}" ${*}
}

function git-review-pull-request	{
    ORIG_HEAD=$(git rev-parse --abbrev-ref HEAD)

    if grep '[.]\{2\}' > /dev/null <<< "${1}"; then
	SPLIT=$(sed 's/[.]\{2\}/\t/g' <<< "${1}")
	FROM_BRANCH=$(cut -f1 <<< "${SPLIT}")
	TO_BRANCH=$(cut -f2 <<< "${SPLIT}")
	shift
    else
	FROM_BRANCH=${1:-origin/master} && shift
	TO_BRANCH=${1:-${ORIG_HEAD}} && shift
    fi

    if test -z "${CMD}"; then
	# NOLESS only makes sense with a command
	NOLESS=''
    fi

    if test -z "${FROM_BRANCH}" || test -z "${TO_BRANCH}"; then
	echo "usage: git-review-pull-request from-branch to-branch"
	# exit 1
	return
    fi
    HASHES=$(git log --reverse "${FROM_BRANCH}".."${TO_BRANCH}"   \
		 --pretty=format:"%h")
    COUNTER=1
    TOTAL=$(wc -l <<< "${HASHES}")
    FAILED=""

    for HASH in $(tr '\n' ' ' <<< ${HASHES}); do

	if test -n "${CMD}"; then
	    git checkout ${HASH}
	    ${CMD} &> /dev/null &
	    COMPILE_CMD_PID=$!
	fi

	if test -z "${NOLESS}"; then
	    { echo -e "------ON COMMIT ${COUNTER}/${TOTAL} (hash: ${HASH})------\n";\
	      git show ${HASH} -p --stat --color;\
	      }  | less -R;
	fi

	COUNTER=$((COUNTER + 1))

	if test -n "${CMD}"; then
	    wait ${COMPILE_CMD_PID}
	    if test $? -ne 0; then
		FAIL="${HASH}: $(git log -1 --pretty=format:%s ${HASH})"
		FAILED="${FAILED}\n${FAIL}"
		${CMD}
		echo ${FAIL}
		echo -p"failure (${CMD}): "
		notify-send "FAILURE (${CMD}): "
		bash
		read -p"cont (q: quit)? : " CONT
		if test "${CONT}" = q; then
		    git checkout ${ORIG_HEAD}
		    return
		fi
	    fi
	fi
    done
    git checkout ${ORIG_HEAD}
    if test -n "${FAILED}"; then
	echo -e "${FAILED}"
    elif test -n "${CMD}"; then
	echo "BUILD SUCCESS on every commit!"
    fi
}

function pid-listening-at	{
    LINE=$(sudo netstat -tlpn 2>/dev/null | grep "[^0-9]${1}[^0-9]")
    PID=$(grep -o '[0-9]*/' <<< "${LINE}" | cut -f1 -d/)
    echo -e "${LINE}\n" 1>&2
    ps -fp ${PID} -w 30 1>&2
    echo ${PID}
}

function git-browse-remote	{
    REMOTE="${1:-origin}" && shift
    URL=$(git config --get "remote.${REMOTE}.url" |  \
	      sed -e 's|:|/|g' -e 's|^\(ssh///\)\?git@|https://|')
    echo ${URL}
    firefox-new-tab "${URL}"
}
# completion with remotes
__git_complete git-browse-remote _git_pull

function cert-fetch	{
    HOSTPORT=${1} && shift
    PEM=/tmp/last-cert.pem
    openssl s_client -showcerts -connect ${HOSTPORT}  \
	    2>/dev/null  \
	    < /dev/null \
	    > ${PEM}

    openssl x509 -in ${PEM} -text -fingerprint | less
    echo ${PEM}
}

function gpom	{
    REMOTE=${1:-origin} && shift
    BRANCH=${1:-$(git rev-parse --abbrev-ref HEAD 2> /dev/null)} && shift
    (
	GIT_TERMINAL_PROMPT=0 git push ${REMOTE} ${BRANCH} &>/dev/null </dev/null
	LAST=$?
	if test 0 -ne $LAST; then
	    echo
	    echo "gpom failed with $LAST!"
	    set -x
	    GIT_TERMINAL_PROMPT=0 git push ${REMOTE} ${BRANCH}
	    set +x
	fi
    ) &
    disown %-
}
__git_complete gpom _git_pull #complete by remote

function mvbk	{
    mv ${1} ${1}.bak
}

function bkmv	{
    mv ${1} $(dirname ${1})/$(basename ${1} .bak)
}

function grvv	{
    REMOTE=${1:-origin} && shift
    git config --get remote.${REMOTE}.url
}
__git_complete grvv _git_pull

function ssh-copy-id-to-user	{
    if test $# -le 3; then
	echo "usage: ssh-copy-id-to-user <SSH_USER> <SSH_HOST> <SSH_PORT> <REMOTE_USER_1> [<REMOTE_USER_2> ...]"
	return 1
    fi

    SSH_USER=${1} && shift
    SSH_HOST=${1} && shift
    SSH_PORT=${1} && shift
    # LOCAL_USER=${1} && shift
    for REMOTE_USER in $*; do
	echo "adding key to user ${REMOTE_USER}"
	ssh  \
	    "-o StrictHostKeyChecking no"\
	    "-o UserKnownHostsFile /dev/null" \
	    "-o StrictHostKeyChecking no" \
	    -p${SSH_PORT} ${SSH_USER}@${SSH_HOST}  \
	    "sudo -u ${REMOTE_USER} bash -s"<<EOF
set -ex
cd
mkdir -p .ssh
cd .ssh
touch authorized_keys
chmod 644 authorized_keys
tee -a authorized_keys <<EOFF
$(cat ~/.ssh/id_rsa.pub)
EOFF
EOF
    done
    set +x
}

function git-remote-exists	{
    REMOTE=${1} && shift
    git config remote.${REMOTE}.url > /dev/null
}

function git-promote-remote-to-origin	{
    EXISTING=${1} && shift
    if test -z "${EXISTING}" || ! git-remote-exists ${EXISTING}; then
	echo "error: remote ${EXISTING} doesn't exist"
    else
	if git-remote-exists origin; then
	    # rename origin
	    OLD_ORIGIN_NEW_NAME=${1:-old-origin} && shift

	    if git-remote-exists ${OLD_ORIGIN_NEW_NAME}; then
		echo "error: provide a new name for origin"
		return
	    else
		git remote rename origin ${OLD_ORIGIN_NEW_NAME}
	    fi
	fi
	git remote rename ${EXISTING} origin
    fi
}
__git_complete git-promote-remote-to-origin _git_pull

function ps-tree	{
    CURR=${1}
    while test ${CURR} != 1; do
	ps -fp ${CURR}
	CURR=$(ps -o ppid= -p ${CURR})
    done
}
